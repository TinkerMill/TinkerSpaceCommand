/*

 ESP8266 MQTT example for driving digital outputs.

 This sketch demonstrates the capabilities of the pubsub library in combination
 with the ESP8266 board/library and digital output.

 It connects to an MQTT server then:
  - subscribes to the topic "/sensors/control", printing out any messages
    it receives. NB - it assumes the received payloads are strings representing hexadecimal longs not binary
  - The bits of the received long are used to turn the digital outputs of the chip on or off.

 It will reconnect to the server if the connection is lost using a blocking
 reconnect function. See the 'mqtt_reconnect_nonblocking' example for how to
 achieve the same result without blocking the main loop.

 To install the ESP8266 board, (using Arduino 1.6.4+):
  - Add the following 3rd party board manager under "File -> Preferences -> Additional Boards Manager URLs":
       http://arduino.esp8266.com/stable/package_esp8266com_index.json
  - Open the "Tools -> Board -> Board Manager" and click install for the ESP8266"
  - Select your ESP8266 in "Tools -> Board"

  Adapted from the supplied MQTT example by Keith M. Hughes.


  ToDo------------------------
  MDNS
  MQTT
  structure that contains topic names (default names)

  End user provides a 
    - SSID, 
    - sensing node: a topic for data on 
                    supply a method that reads the sensors
                      we provide a method to put the json message toghther
*/


#include <SpaceNode.h>

// Global static pointer to ensure a singleton instance of the class
SpaceNode* SpaceNode::m_pInstance = NULL;

/* This function is called to create an instance of the class
 * Calling the constructor publicaly is not allowed.
 * The constructor is private and only called by the Instance method
 *  Usage - SpaceNode* node = SpaceNode::Instance();
 *  If you call the SpaceNode::Instance method more than once it will always return the
 *  same method. i.e. - SpaceNode* node2 = SpaceNode::Instance();
 *  Then node1 == node2 b/c they refer to the same object.
 */
SpaceNode* SpaceNode::Instance(){
  if(!m_pInstance){
    m_pInstance = new SpaceNode();
  }
  return m_pInstance;
}


// Constructor - Overloaded 2 types
//SpaceNode::SpaceNode(const char* _mqttControlInputTopic = "/tinkermill/sensors/control", WiFiClient _wifiClient, PubSubClient _mqttClient){
SpaceNode::SpaceNode(){
}

// Deconstructor
SpaceNode::~SpaceNode(){ /*Nothing to Deconstruct*/ };


// Set up the program.
// This function is called once when the program starts.
void SpaceNode::setupNode(
   const char* _mqttDataOutputTopic = "/tinkermill/sensors/data",
   const char* _mqttControlInputTopic = "/tinkermill/sensors/control") {

  // The topic to publish to.
  m_mqttDataOutputTopic = _mqttDataOutputTopic;

  // The topic to subscribe to.
  m_mqttControlInputTopic = _mqttControlInputTopic;


  // The following describe the MQTT topics and client ID.
  // The ID the MQTT client should have.
 // This should have something unique, like your name.
  // However, we will autogenerate it using the ESP Chip ID.
  //char mqttClientId[64];

  // The host name for the chip on mDNS.
  // This will be autogenerated.
  //char hostName[24];

  // The WiFi client used to connect to the wireless network.
  //m_wifiClient = _wifiClient;
  // WiFiClient m_wifiClient(); // SL Note: turned this off

  // The MQTT Pub/Sub client
  //PubSubClient mqttClient(wifiClient);
  m_mqttClient.setClient(m_wifiClient); 
  //m_mqttClient = _mqttClient;

  // Run setup method
  //setup();

  Serial.print("ESP Chip ID is ");
  Serial.println(ESP.getChipId());

  // Create a host name for the chip.
  sprintf(m_hostname, "esp8266_%06X", ESP.getChipId());
  Serial.print("Host Name: ");
  Serial.println(m_hostname);

  // Create an MQTT client ID likely unique.
  sprintf(m_mqttClientId, "sensor.%s", m_hostname);
  Serial.print("MQTT Client ID: ");
  Serial.println(m_mqttClientId);

  setupMqttConnection();
}

// The function to be called whenever a message comes in on
// the input topic.
void SpaceNode::processIncomingMqttMessage(
    char* topic, byte* payload, unsigned int length) {
  
  // The writable pins on the Sparkfun Thing Dev board.
  int static_writablePins[] = { 0, 2, 4, 5, 12, 13, 14, 15, 16 };

  // The number of writable pins
  int static_numWritablePins = sizeof(static_writablePins) / sizeof(int);


  Serial.print("MQTT Message arrived [");
  Serial.print(topic);
  Serial.print("] ");
  for (int i = 0; i < length; i++) {
    Serial.print((char)payload[i]);
  }
  Serial.println();

  // The Arduino MQTT library has a fixed internal buffer and will overwrite
  // old payloads with new payloads. If the new payload is shorter than the
  // old payload, the latter part of the old payload will still be visible
  // in the buffer. So null-terminate the string at the length of the new
  // payload to play it safe.
  payload[length] = NULL;

  // Parse the hex string
  long messageBits = strtol((char *)payload, NULL, 16);
  long pinBit = 1;
  Serial.println(messageBits, HEX);

  // For each writable pin, see if that pin should be turned on or off.
  long pinIndex = 0;
  while (pinIndex < static_numWritablePins) {
    if (pinIndex != 0){
      int pinNumber = static_writablePins[pinIndex];
      int pinValue = messageBits & pinBit ? HIGH : LOW;

      Serial.print(pinNumber);
      Serial.print(" => ");
      Serial.println(pinValue);

      digitalWrite(pinNumber, pinValue);

      pinBit <<= 1;
    }
    pinIndex++;
  }
}

// Use mDNS to locate an MQTT broker and attach.
void SpaceNode::setupMqttConnection() {
  if (!MDNS.begin(m_hostname)) {
    Serial.println("Unable to set up mDNS");
  }

  // Scan until an MQTT broker is found
  while (true) {
    int n = MDNS.queryService("mqtt", "tcp");
    if (n == 0) {
      Serial.println("No MQTT services found.");
    } else {
      Serial.println("Found MQTT");
      Serial.println(MDNS.hostname(0));
      Serial.println(MDNS.IP(0));
      Serial.println(MDNS.port(0));
    
      // Set the MQTT server and port to attach to.
      m_mqttClient.setServer(MDNS.IP(0), MDNS.port(0));

      Serial.println("mqtt Server is set, setting Callback next");

      // Set the function to be called every time a message comes in.
      // Set callback to a static function since you cannot easily pass a 
      // member function to the PubSubClient.setCallback() method, since
      // the expected signature is looking for a standard function
      // not a member function (maybe fix for future version)
      m_mqttClient.setCallback(&SpaceNode::processIncomingMqttMessage);
      Serial.println("MQTT callback is set");

      break;
    }
  }
}


// The connection to the MQTT broker has been lost. Try and reconnect.
void SpaceNode::reconnectMqtt() {
  // Loop until we're reconnected
  while (!m_mqttClient.connected()) {
    Serial.print("Attempting MQTT connection...");
    Serial.println("");
    Serial.print("m_mqttClientId: ");
    Serial.println(m_mqttClientId);
    // Attempt to connect
    if (m_mqttClient.connect(m_mqttClientId)) {
      Serial.println("connected");
      
      // Resubscribe to the control topic.
      m_mqttClient.subscribe(m_mqttControlInputTopic);
    } else {
      Serial.print("failed, rc=");
      Serial.print(m_mqttClient.state());
      Serial.println(" try again in 5 seconds");
      
      // Wait 5 seconds before retrying
      delay(5000);
    }
  }
}

bool SpaceNode::isMqttConnected(){
  return m_mqttClient.connected();
}

void SpaceNode::loopNode(){
  // If not connected to the MQTT broker, either because has
  // never been connected or because the connection was lost.
  if (!isMqttConnected()) {
    reconnectMqtt();
  }

  // Have the MQTT client process any data.
  m_mqttClient.loop();
}

void SpaceNode::publishHeartbeat(){
  StaticJsonBuffer<200> jsonBuffer;

  JsonObject& jsonRoot = jsonBuffer.createObject();
  jsonRoot["sensorId"] = m_mqttClientId;
  jsonRoot["messageType"] = "heartbeat";

  yield();

  char json_buffer[200];
  jsonRoot.printTo(json_buffer, sizeof(json_buffer));

  m_mqttClient.publish(m_mqttDataOutputTopic, json_buffer);

  yield();
  
  this->loopNode();

  yield();

  jsonBuffer.clear();
}

void SpaceNode::publishMeasurement(
     char * channelId,
     char *measurementType, 
     float measurementValue){

  StaticJsonBuffer<512> jsonBuffer;

  JsonObject& jsonRoot = jsonBuffer.createObject();
  jsonRoot["sensorId"] = m_mqttClientId;
  jsonRoot["messageType"] = "measurement";
  JsonObject& data = jsonRoot.createNestedObject("data");

  JsonObject& value = data.createNestedObject(channelId);
  value["value"] = measurementValue;
  value["type"] = measurementType;

  this->sendMqttMessage(jsonRoot);
}

void SpaceNode::publishMeasurement(
     char * channelId,
     char *measurementType, 
     int measurementValue){

  StaticJsonBuffer<512> jsonBuffer;

  JsonObject& jsonRoot = jsonBuffer.createObject();
  jsonRoot["sensorId"] = m_mqttClientId;
  jsonRoot["messageType"] = "measurement";
  JsonObject& data = jsonRoot.createNestedObject("data");

  JsonObject& value = data.createNestedObject(channelId);
  value["value"] = measurementValue;
  value["type"] = measurementType;

  this->sendMqttMessage(jsonRoot);
}

void SpaceNode::publishMeasurement(
     char* channelId,
     char* measurementType, 
     char* measurementValue){

  StaticJsonBuffer<512> jsonBuffer;

  JsonObject& jsonRoot = jsonBuffer.createObject();
  jsonRoot["sensorId"] = m_mqttClientId;
  jsonRoot["messageType"] = "measurement";
  JsonObject& data = jsonRoot.createNestedObject("data");

  JsonObject& value = data.createNestedObject(channelId);
  value["value"] = measurementValue;
  value["type"] = measurementType;

  this->sendMqttMessage(jsonRoot);
}

void SpaceNode::sendMqttMessage(
    JsonObject& jsonRoot) {
  
  jsonRoot.prettyPrintTo(Serial);

  yield();

  char serializedJsonBuffer[512];
  
  int length = jsonRoot.printTo(serializedJsonBuffer, sizeof(serializedJsonBuffer));
  serializedJsonBuffer[length] = 0;

  Serial.println(serializedJsonBuffer);
  
  bool res = m_mqttClient.publish(m_mqttDataOutputTopic, serializedJsonBuffer);
  Serial.println(res);
  
  yield();
  
  this->loopNode();

  yield();
}

